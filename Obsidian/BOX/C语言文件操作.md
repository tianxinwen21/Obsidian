#input #CS #programming_language 
# C语言文件操作

## 1. 为什么使用文件件

- 当数据存放在内存中, 数据会随着程序的退出而消失不见了. 只有等下次程序启动时, 数据才会被重新读入.
- 我们就会想, 有没有一种方法可以让数据永久保存, 只有当我们需要删除时, 数据才会消失不见 .
- 一般数据想要持久保存的方法有两种: 一是把数据存放在磁盘文件, 二是存放到数据库中 .
- 当我们使用文件时, 我们就可以将数据直接保存在电脑的硬盘上 .

- **硬盘和磁盘** :
![[Pasted image 20221129102335.png]]
## 2. 什么是文件

- 磁盘上的文件是文件 .
- 从文件功能的角度文件可以分两种: **程序文件** 和 **数据文件** .

### 2.1 程序文件
1. 源程序文件 (后缀为 **.c**);
2. 目标文件 (Windows 环境后缀为 **.obj** );
3. 可执行程序 (Windows 环境后缀为 **.exe** ).

### 2.2 数据文件

- 程序运行时读写的数据 .

- **终端** ：
![[Pasted image 20221129100008.png]]

>我们之前所处理的数据的输入输出都是在终端上进行的, 我们从键盘终端输入数据, 再从显示器终端输出数据. 
>学习了文件这一章节,我们输出数据和输出数据的对象就变成了磁盘上的文件. 


### 2.3 文件名

- 文件名就是文件的唯一一个 **标识符** .

- 文件名由三部分组成: **文件路径 + 文件名主干 + 文件后缀** .
例如: `c:\code\test.txt` 
`c:\code\` 是文件路径;
`test` 是文件名;
`.text` 是文件后缀 .

## 3. 文件的打开和关闭

### 3.1 文件指针

- 缓冲文件系统中, 关键的概念就是 **类型指针**, 简称 **文件指针** .
- 每个被使用的文件都在内存中开辟了一个相应的 **文件信息区**, 用来存放文件的相关信息,比如: 文件名,文件的状态以及文件当前的位置等 .这些信息是保存在一个 **结构体变量** 中.改结构体类型是有系统声明的,名字叫 **FILE** .

- 例如,VS2013编译环境提供的 `stdio.h` 头文件中有以下文件类型声明 :
```c
struct _iobuf {
    char* _ptr;
    int   _cnt;
    char* _base;
    int   _flag;
    int   _file;
    int   _charbuf;
    int   _bufsiz;
    char* _tmpfname;
};
typedef struct _iobuf FILE;
```

- 不同的C编译器的FILE类型包含的内容不完全相同 .

- 每打开一个文件的时候, 系统会根据文件的情况自动创建一个FILE结构的变量, 并写入相关信息 .

- 一般都是通过一个FILE的指针来维护这个FILE结构的变量, 如下:
```c
FILE* pf;//文件指针变量
```

- `pf` 指向某个文件的文件信息区, **通过文件指针变量能够找到它相关联的文件** .

![[Pasted image 20221129114746.png]]

### 3.2 文件的打开和关闭

- 文件在读写之前应该先 **打开文件** ,在使用结束之后应该 **关闭文件** .

- 在编写程序的时候, 再打开文件的同时, 都会返回一个 `FILE*` 的指针变量指向该文件, 相当于建立了指针和文件的关系 .

- `ANSIC` 规定使用 `fopen` 函数来打开文件, `fclose` 函数来关闭文件 .
```c
//打开文件
FILE* fopen(const char* filename, const char* mode);
//关闭文件
int fclose(FILE* stream);
```

- **打开方式如下** :

 | **文件使用方式** | **含义**                                 | **如果指定文件不存在** |
| ------------ | ------------------------------------ | ------------------ |
| **"R" (只读)**   | 为了输入数据, 打开一个已经存在的文件 | 出错               |
| **"W" (只写)**   | 为了输出数据, 打开一个文本文件       | 建立一个新的文件   |
| **"a" (追加)**   | 向文本文件尾添加数据                 | 建立一个新的文件   |
| "rb"（只读） | 为了输入数据，打开一个二进制文件     | 出错               |
| "wb" (只写)  | 为了输出数据, 打开一个二进制文件     | 建立一个新文件     |
| "ab" (追加)  | 向一个二进制文件尾添加数据           | 出错               |
| "r+" (读写)  | 为了读和写, 打开一个文本文件         | 出错               |
| "w+" (读写)  | 为了读和写, 建立一个新的文件         | 建立一个新的文件   |
| "a+" (读写)  | 打开一个文件, 在文件尾进行读写       | 建立一个新的文件   |
| "rb+" (读写) | 为了读和写打开一个二进制文件         | 出错               |
| "wb+" (读写) | 为了读和写, 新建一个新的二进制文件   | 建立一个新的文件   |
| "ab+" (读写)             | 打开一个二进制文件, 在文件尾进行读和写                                     | 建立一个新的文件                   |

```c

```
## 4.文件的顺序读取






##  5.文件的随机读取

### 5.1 fseek
* 根据文件指针的位置和偏移量来定位文件指针

```c
int fseek (FILE* stream, long int offset, int origin);
```

```c

```

### 5.2 ftell
- 返回文件指针相对于起始位置的偏移量

```c
long int ftell (FILE* stream);
```

```c

```

### 5.3 rewind
- 让文件指针的位置返回到文件的起始位置.

```c
void rewind (FILE* stream);
```

```c

```

## 6. 文本文件和二进制文件

- 根据数据的组织形式,数据文件被称为: **文本文件** 或 **二进制文件** .
- 数据在内存中以二进制的形式储存, 如果不加转换的输出到外存, 就是 **二进制文件** .
- 以 **ASCII码** 字符的形式存储的文件就是 **文本文件** .
- 字符一律以ASCII码的形式存储 .
- 数值型数据既可以用ASCII码形式存储, 也可以使用二进制形式存储 .



## 7. 文件读取结束的判断
### 7.1 被错误使用的feof

- 正在文件读取过程中, **不能用 `feof` 函数的返回值直接用来判断文件是否结束** . 而是 **应用于当文件读取结束的时候, 判断是读取失败结束, 还是遇到文件尾结束** .

1. 文本文件读取是否结束, 判断返回值是否为 `EOF` ( `fgetc` ), 或者 `NULL` ( `fgets` ).
2. 二进制文件的读取结束判断, 判断返回值是否小于实际要读的个数 .



## 8. 文件缓冲区
- ANSIC 标准采用“缓冲文件系统”处理的数据文件的 .
- 所谓缓冲文件系统是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”.
- 从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上.
- 如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区（充满缓冲区）.
- 然后再从缓冲区逐个地将数据送到程序数据区（程序变量等) .缓冲区的大小根据C编译系统决定的.

```c

```

>[!结论]
>因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文件.