#input #CS #programming_language 

## 1.封装

### 1.1什么是封装

面向对象程序三大特性：封装、继承、多态。

在类和对象阶段，主要研究的就是封装特性。封装简单来说就是**套壳隐蔽细节。**

**封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性 和实现细节，仅对外公开接口来和对象进行交互**。



### 1.2访问限定符

Java中主要通过类和访问权限来实现封装：**类可以将数据以及封装数据的方法结合在一起**，而**访问权限来控制方法或者字段能否直接在类外使用。**Java中提供了四种访问限定符：

|      | 范围             | private | default | protected | public |
| ---- | ---------------- | ------- | ------- | --------- | ------ |
| 1    | 同一包中的同一类 | yes     | yes     | yes       | yes    |
| 2    | 同一包中的不同类 |         | yes     | yes       | yes    |
| 3    | 不同包中的子类   |         |         | yes       | yes    |
| 4    | 不同包中的非子类 |         |         |           | yes    |

public:可以理解为一个人的外貌特征谁都可以看到

default：只属于自己一个家族（同一个包中）

private：只有自己知道，其他人都不知道

**补充**：

* protected主要是用在继承中
* default权限指：什么都不写时的默认权限
* 访问权限除了可以限定类中成员的可见性，也可以控制类的可见性

注意：一般情况下成员变量设置为private，成员方法设置为public。



## 2. 继承

### 2.1继承概念

**继承(inheritance)机制：**是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性 的基础上**进行扩展，增加新功能，**这样产生新的类，称**派生类。**继承呈现了面向对象程序设计的层次结构， 体现了 由简单到复杂的认知过程。继承主要解决的问题是：***共性的抽取，实现代码复用。***

例如：Dog和Cat都继承了Animal类，其中：Animal类称为**父类、基类或者超类，**Dog和Cat称为Animal的**子类或派生类**，继承之后，子类可以复用父类中成员，子类在实现时只需关心自己新增加的成员即可。



### 2.2 继承的语法

借助**extends**关键字：

```java
修饰符 class 子类 extends 父类{
    ···
}
```

例如：

```java
```

**[注意]**

1. 子类会将父类中的成员变量或者成员方法继承到子类中了
2. 子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了



### 2.3 父类成员访问

***有限访问自己，如果没有则向父类中找***

#### 2.3.1 子类访问父类的成员变量

**成员变量访问遵循就近原则，自己有优先自己的，如果没有则向父类中找。**

1. 子类和父类不存在同名成员变量

       ```java
       
       ```

2. 子类和父类成员变量同名

```java
```

**在子类方法中 或者 通过子类对象访问成员时：**

* 如果访问的成员变量子类中有，优先访问自己的成员变量
* 如果访问的成员变量子类中无，则访问父类继承下来的，如果父类也没有定义，则编译报错。
* 如果访问的成员变量与父类中成员变量同名，则优先访问自己的。

#### 2.3.2子类中访问父类的成员方法

1. 成员方法名字不同

```java
```

2.  成员方法名字相同

```java
```

**[注意]**

* 通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到 则访问，否则编译报错。
* 通过派生类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同(重载)，根据调用 方法适传递的参数选择合适的方法访问，如果没有则报错；

*问题：如果子类中存在与父类中相同的成员时，那如何在子类中访问父类相同名称的成员呢？*引出super。



### 2.4 super关键字

由于设计不好，或者因场景需要，子类和父类中可能会存在相同名称的成员，如果要在子类方法中访问父类同名成 员时，该如何操作？直接访问是无法做到的，Java提供了**super关键字，该关键字主要作用：在子类方法中访问父 类的成员。**

```java
```

**[注意]**

1. 只能在非静态方法中使用
2. 在子类方法中，访问父类的成员变量和方法



### 2.5 子类构造方法

父子父子，先有父再有子，即：子类对象构造时，**需要先调用基类构造方法，然后执行子类的构造方法。**

```java
```

在子类构造方法中，并没有写任何关于基类构造的代码，但是在构造子类对象时，先执行基类的构造方法，然后执 行子类的构造方法，因为：**子类对象中成员是有两部分组成的，基类继承下来的以及子类新增加的部分 。父子父子 肯定是先有父再有子，所以在构造子类对象时候 ，先要调用基类的构造方法，将从基类继承下来的成员构造完整 ，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整 。**

**[注意]**

1. 若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的super()调用，即调用基类构造方法
2. 如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的 父类构造方法调用，否则编译失败。
3. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句。
4. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现



### 2.6 super和this

super和this都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语 句

#### 2.6.1 相同点

1. 都是Java中的关键字
2. 只能在类的非静态方法中使用，用来访问非静态成员方法和字段
3. . 在构造方法中调用时，必须是构造方法中的第一条语句，并且**不能同时存在**

#### 2.6.2 不同点

1. this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用
2. 在非静态成员方法中，this用来访问本类的方法和属性，super用来访问父类继承下来的方法和属性
3. 在构造方法中：this(...)用于调用本类构造方法，super(...)用于调用父类构造方法，两种调用不能同时在构造 方法中出现
4. 构造方法中一定会存在super(...)的调用，用户没有写编译器也会增加，但是this(...)用户不写则没有



### 2.7 代码块执行顺序

**无继承时的执行顺序：**

>1. 静态代码块**先**执行，并且只执行一次，在类加载阶段执行
>2.  当有对象创建时，才会执行实例代码块，**实例代码块执行完成后，最后构造方法执行**

**有继承时的执行顺序：**

```java
```

```java
```

>1. 父类静态代码块优先于子类静态代码块执行，且是最早执行
>2. 父类实例代码块和父类构造方法紧接着执行
>3. 子类的实例代码块和子类构造方法紧接着再执行
>4. 第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行



### 2.8 protected 关键字

```java
```

**[注意]**

父类中private成员变量虽然在子类中不能直接访问，但是也继承到子类中了。



### 2.9 继承方式

| 单继承             | public class A{···} <-- public class B extends A{···}        |
| ------------------ | ------------------------------------------------------------ |
| 多层继承           | public class A {···} <-- public class B extends A{···} <-- public class C extends B{···} |
| 不同类继承同一个类 | public class A{···} <-- public class B extends A{···} + public class C extends A{···} |
| 不支持多继承       | public class C extends A,B{···}                              |



### 2.10 final 关键字

final关键可以用来修饰变量、成员方法以及类。

1. 修饰变量或字段，表示常量(即不能修改)
2.  修饰类：表示此类不能被继承
3. 修饰方法：表示该方法不能被重写

*我们平时使用的 String 字符串类, 就是用 final 修饰的, 不能被继承*



### 2.11 继承和组合

和继承类似, 组合也是一种表达类之间关系的方式, 也是能够达到代码重用的效果。组合并没有涉及到特殊的语法 (诸如 extends 这样的关键字), 仅仅是将一个类的实例作为另外一个类的字段。

继承表示对象之间是**is-a的关系**，比如：狗是动物，猫是动物

组合表示对象之间是**has-a的关系，**比如：汽车

汽车和其轮胎、发动机、方向盘、车载系统等的关系就应该是组合，因为汽车是有这些部件组成的。

```java
```

组合和继承都可以实现代码复用，应该使用继承还是组合，需要根据应用场景来选择，一般建议：能用组合尽量用 组合.



## 3. 多态

### 3.1 多态的概念

多态的概念：通俗来说，就是多种形态，**具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。**

例如：

打印机打印，彩色打印机打印效果是彩色，黑白打印机打印效果是黑白；

eat，猫eat猫粮，狗eat狗粮。

总的来说：同一件事，发生在不同的对象身上，就会产生不同的结果。



### 3.2 多态实现条件

在java中要实现多态，必须要满足如下几个条件，缺一不可：

1. **必须在继承体系下**
2. **子类必须要对父类中方法进行重写**
3. **通过父类的引用调用重写的方法**

**多态体现：在代码运行时，当传递不同类对象时，会调用对应类中的方法。**

```java
```

在上述代码中, 分割线上方的代码是**类的实现者**编写的, 分割线下方的代码是 类的**调用者** 编写的. 当类的调用者在编写 eat 这个方法的时候, 参数类型为 Animal (父类), 此时在该方法内部并不知道, 也不关注当前的 a 引用指向的是哪个类型(哪个子类)的实例. 此时 a这个引用调用 eat方法可能会有多种不同的表现(和 a 引用的实例 相关), 这种行为就称为 **多态.**



### 3.3 重写

重写(override)：也称为覆盖。重写是子类对父类非静态、非private修饰，非final修饰，非构造方法等的实现过程 进行重新编写, **返回值和形参都不能改变。即外壳不变，核心重写**重写的好处在于子类可以根据需要，定义特定 于自己的行为。 也就是说子类能够根据需要实现父类的方法。

**[规则]**

* 子类在重写父类的方法时，一般必须与父类方法原型一致： 返回值类型 方法名 (参数列表) 要完全一致
* 被重写的方法返回值类型可以不同，但是必须是具有父子关系的
* 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被public修饰，则子类中重写该方 法就不能声明为 protected
* 父类被static、private修饰的方法、构造方法都不能被重写 
* 重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验. 例如不小心 将方法名字拼写错了 (比如写成 `aet`), 那么此时编译器就会发现父类中没有 `aet` 方法, 就会编译报错, 提示无法 构成重写.

#### 3.3.1 重写和重载的区别

| 区别点     | 重写（override）                       | 重载（override） |
| ---------- | -------------------------------------- | ---------------- |
| 参数列表   | 一定不能修改                           | 必须修改         |
| 返回类型   | 一定不能修改【除非可以构成父子类关系】 | 可以修改         |
| 访问限定符 | 一定不能更严格的限制（可以降低限制）   | 可以修改         |

*即：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。*

**[重写的设计原则]**

对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容， 并且添加或者改动新的内容。

例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅 可以显示号码，还可以显示头像，地区等。在这个过程当中，我们不应该在原来老的类上进行修改，因为原来的 类，可能还在有用户使用，正确做法是：新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我 们当今的需求了。

**静态绑定：**也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代 表函数重载。

**动态绑定：**也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体 调用那个类的方法。



### 3.4 向上转型和向下转型

#### 3.4.1 向上转型

向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。

语法格式：

```java
父类类型 对象名 = new 子类类型（）
Animal animal = new Cat("元宝"，9)；
```

animal是父类类型，但可以引用一个子类对象，因为是从小范围向大范围的转换。

**[使用场景]**

1. 直接赋值
2. 方法传参
3. 方法返回

```java
```

**向上转型的优点：让代码实现更简单灵活。**

**向上转型的缺陷：不能调用到子类特有的方法。**

#### 3.4.2 向下转型

将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的 方法，此时：将父类引用再还原为子类对象即可，即向下转换。

```java
```

向下转型用的比较少，而且不安全，万一转换失败，运行时就会抛异常。Java中为了提高向下转型的安全性，引入 了 `instanceof` ，如果该表达式为true，则可以安全转换。

```java
```

### 3.5 多态的优缺点

```java

```

**多态的有点：**

1. 能够降低代码的 "圈复杂度", 避免使用大量的 if - else

> 什么叫 "圈复杂度" ? 圈复杂度是一种描述一段代码复杂程度的方式. 一段代码如果平铺直叙, 那么就比较简单容易理解. 而如 果有很多的条件分支或者循环语句, 就认为理解起来更复杂. 因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数, 这个个数就称为 "圈复杂度". 如果一个方法的圈复杂度太高, 就需要考虑重构. 不同公司对于代码的圈复杂度的规范不一样. 一般不会超过 10 .

```java
```

如果使用多态, 则不必写这么多的 if - else 分支语句, 代码更简单.

```java
```

2. 可扩展能力更强

​        如果要新增一种新的形状, 使用多态的方式代码改动成本也比较低.对于类的调用者来说(`drawShapes`方法), 只要创建一个新类的实例就可以了, 改动成本很低. 而对于不用多态的情况, 就要把 `drawShapes` 中的 if - else 进行一定的修改, 改动成本更高.

**多态缺点：**代码的运行效率降低。

**[注意]**

1. 属性没有多态性 当父类和子类都有同名属性的时候，通过父类引用，只能引用父类自己的成员属性
2. 构造方法没有多态性



### 3.6 避免在构造方法中调用重写的方法

一段有坑的代码. 我们创建两个类, B 是父类, D 是子类. D 中重写 func 方法. 并且在 B 的构造方法中调用` func`

```java
```

* 构造 D 对象的同时, 会调用 B 的构造方法
* B 的构造方法中调用了 `func` 方法, 此时会触发动态绑定, 会调用到 D 中的`func`
* 此时 D 对象自身还没有构造, 此时 `num` 处在未初始化的状态, 值为 0. 如果具备多态性，`num`的值应该是1
* 所以在构造函数内，尽量避免使用实例方法，除了final和private方法。

**结论:** "用尽量简单的方式使对象进入可工作状态", 尽量不要在构造器中调用方法(如果这个方法被子类重写, 就会触 发动态绑定, 但是此时子类对象还没构造完成), 可能会出现一些隐藏的但是又极难发现的问题.

