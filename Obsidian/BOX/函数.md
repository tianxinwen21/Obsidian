#input #CS #programming_language 
# 函数

## 1. 函数是什么

函数可以看做是一个**子程序**,由某部分代码组成,负责完成某项特定的任务,具有独立性.

## 2.C语言中函数的分类

1. 库函数
2. 自定义一函数

### 2.1 库函数

有些代码在开发的过程中每个程序员都可能用到,为了支持可移植性和提高程序的效率,所以C语言的基础库中提供了一系列类似的库函数,方便开发.

**常用库函数:**

* IO函数
* 字符串操作函数
* 字符操作函数
* 内存操作函数
* 时间/日期函数
* 数学函数
* 其他库函数

**注意:**

使用库函数，必须包含 `#include` 对应的头文件。

**库函数查询工具:**

www.cplusplus.com

http://en.cppreference.com（英文版)

http://zh.cppreference.com（中文版）

### 2.2 自定义函数

程序员自己设计的函数.

```c
返回类型 函数名 (函数参数)
{
    语句项;
}
```

**举一个例子:**

> 写一个函数找出两个整数中的最大值

```c
#include<stdio.h>
int get_max(int x,int y)
{
    return (x>y)?(x):(y);
}
int main()
{
    int a = 10;
    int b = 20;
    int max = get_max(a,b);
    printf("%d\n",max);
    return 0;
}
```

## 3.函数的参数

### 3.1 实际参数(实参)

**真实传给函数的参数,叫实参.**

实参可以是:常量,变量,表达式,函数等.

无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形 参。

### 3.2 形式参数(形参)

**形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内 存单 元），所以叫形式参数。**

形式参数当函数调用完成之后就自动销毁了。因此形式参数只在函数中有 效。



形参拥有和实参一模一样的内容.

所以可以简单的认为:**形参实例化之后其实相当于实参的一份临时拷贝.**



## 4. 函数的调用

### 4.1传值调用

函数的形参和实参分别占有**不同内存块**，对形参的修改不会影响实参。

### 4.2 传值调用

* 传址调用是把函数外部创建变量的**内存地址**传递给函数参数的一种调用函数的方式。
* 这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是函数内部可以直接操 作函数外部的变量。

**经典例题:**

> 交换两个数

```c
#include<stdio.h>

int swap1(int* n,int* m)
{
    int tmp = 0;
    tmp = *n;
    *n = *m;
    *m = tmp;
}
int main()
{
    int a = 10;
    int b = 20;
    swap1(&a,&b);
    printf("%d %d\n",a,b);
    return 0;
}
```





## 5. 函数的嵌套调用和链式访问

函数和函数之间可以根据实际的需求进行组合的，也就是互相调用的。

### 5.1 嵌套调用

```c
#include <stdio.h>
void new_line()
{
 printf("hehe\n");
}
void three_line()
{
    int i = 0;
 for(i=0; i<3; i++)
   {
        new_line();
   }
}
int main()
{
 three_line();
 return 0;
}
```

**函数可以嵌套调用,但是不能嵌套定义.**

### 5.2 链式访问

把一个函数的返回值作为另外一个函数的参数。

```c
#include <stdio.h>
int main()
{
    printf("%d", printf("%d", printf("%d", 43)));
    //结果是啥？
    //注：printf函数的返回值是打印在屏幕上字符的个数
    return 0;
}
//4321
//printf函数返回的是个数
```



## 6. 函数的声明和定义

### 6.1 函数声明(.h 文件中)

1. 告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，函数 声明决定不了。
2. 函数的声明一般出现在函数的使用之前。要满足先声明后使用。
3. 函数的声明一般要放在头文件中的。

```c
int Add(int x,int y);
```



### 6.2 函数定义(.c 文件中)

函数的定义是指函数的具体实现，交待函数的功能实现。

```c
#include "test.h"
//函数Add的实现
int Add(int x, int y)
{
 return x+y;
}
```



## 7. 函数递归

**什么是递归:**自己调用自己

> 程序**调用自身**的编程技巧称为递归（ recursion）。 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接 调用自身的 一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解， 递归策略 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 递归的主要思考方式在于：**把大事化小**

### 7.1 两个必要条件

* 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
* 每次递归调用之后越来越接近这个限制条件

### 7.2 练习

> 1. 输入1234,输出1 2 3 4

```c
#include <stdio.h>

void print(int n)
{
    if(n>9)
    {
        print(n/10);
    }
    printf("%d ",n%10);
}

int main()
{
    int num = 1234;
    print(num);
    return 0;
}
```



> 2. 编写函数不允许创建临时变量,求字符串的长度

```c
#include <stdio.h>

int Strlen(char* str)
{
    if(*str == '\0')
        return 0;
    else
        return 1+Strlen(str+1);
}
int main()
{
    char* p = "abcdef";
    int len = Strlen(p);
    printf("%d\n",len);
    return 0;
}
```



### 7.3 递归与迭代

> 求n的阶乘(不考虑益处)

```c
int factorial(int n)
{
 if(n <= 1)
 		return 1;
 else
 		return n * factorial(n-1);
}
```

> 求第n个斐波那契数。（不考虑溢出）

```c
int fib(int n)
{
 if (n <= 2)         
 	return 1;
 else
    return fib(n - 1) + fib(n - 2);
}
```

**会发现递归会重复大量实验,耗费时间.**

当参数较大时可能会出现栈溢出的情况,所以我们可以将递归改成非递归使用迭代的方法.循环知识迭代的一种方式.迭代和递归可以互补,来提高效率.



非递归方式:

> 求n 的阶乘

```c
int factorial(int n)
{
        int result = 1;
        while (n > 1)
       {
             result *= n ;
             n -= 1;
       }
        return result;
}
```

> 求第n个裴波那契数

```c
int fib(int n)
{
     int a;
     int b;
     int c;
     a = b = 1;
     while (n > 2)
     {
           n -= 1;
           c = b;
           b = a;
           a = b + c;
     }
     return a;
}
```

