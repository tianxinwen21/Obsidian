#input #CS #programming_language 
# 操作符

## 1.操作符类型

* 算术操作符
* 移位操作符
* 位操作符
* 赋值操作符
* 单目操作符
* 关系操作符
* 逻辑操作符
* 条件操作符
* 逗号表达式
* 下表引用,函数调用和结构成员



## 2. 算术操作符

```c
+ - * / %
```

**注意:**

1. 除了 `%` 操作符之外，其他的几个操作符可以作用于整数和浮点数。
2. 除了` %` 操作符之外，其他的几个操作符可以作用于整数和浮点数。
3. `% `操作符的两个操作数必须为整数。返回的是整除之后的余数。
4. `/`和`% `除数都不能是0.



## 3.移位操作符

```c
<< 左移操作符
>> 右移操作符
    
注: 移位操作符的操作数只能是整数.
```

### 3.1 左移操作符

**移位规则:**

* 左边抛弃,右边补0

### 3.2 右移操作符

**移位规则:**

分两种:

1. 算术右移(一般采用)

   左边用原该值的符号位填充,右边丢弃

2. 逻辑移位

   左边用0填充,右边丢弃

**警告:**

对于移位运算符，不要移动负数位，这个是标准未定义的。



## 4. 位操作符

位操作符有:

```c
& //按位与(都为1才为1)
| //按位或(见1为1)
^ //按位异或(相同为0,相异为1)
    
注: 它们的操作数必须是整数
```

**^:**

```c
int a = 1;
//0 ^ a = a;
//a ^ a = 0;
//满足交换律 (a ^ b ^ a = a ^ a ^ b = b)
```



练习1:

> 不创建临时变量,实现两个数的交换

```c
#include <stdio.h>
int main()
{
 int a = 10;
 int b = 20;
 a = a^b;
 b = a^b;
 a = a^b;
 printf("a = %d b = %d\n", a, b);
 return 0;
}
```

练习2:

> 求一个整数存储在内存中的二进制中1的个数

```c
//方法1
#include <stdio.h>
int main()
{
 int num  = 10;
int count=  0;//计数
 while(num)
 {
 if(num%2 == 1)
 count++;
 num = num/2;
 }
 printf("二进制中1的个数 = %d\n", count);
 return 0;
}
//思考这样的实现方式有没有问题？
//方法2：
#include <stdio.h>
int main()
{
 int num = -1;
 int i = 0;
 int count = 0;//计数
 for(i=0; i<32; i++)
 {
 if( num & (1 << i) )
 count++; 
 }
 printf("二进制中1的个数 = %d\n",count);
 return 0;
}
//思考还能不能更加优化，这里必须循环32次的。
//方法3：
#include <stdio.h>
int main()
{
 int num = -1;
 int i = 0;
 int count = 0;//计数
 while(num)
 {
 count++;
 num = num&(num-1);
 }
 printf("二进制中1的个数 = %d\n",count);
 return 0;
}
//这种方式是不是很好？达到了优化的效果，但是难以想到。
```



## 5. 赋值操作数

赋值操作数就是重新赋一个值.

```c
int weight = 120;
weight = 90;

也可连续使用:
int a = 10;
int b = 20;
int c = 30;
c = a = b + 10;
```

 **复合赋值符:**

* +=
* -=
* *=
* /=
* %=
* `>>=`
* <<=
* &=
* |=
* ^=

复合效果:

```c
int x = 10;
x = x+10;
x += 10;//复合赋值
//其他运算符一样的道理。这样写更加简洁。
```



## 6. 单目操作符

```
!            逻辑反操作
-            负值
+            正值
&            取地址
sizeof       操作数的类型长度(一字节为单位)
~            对一个数的二进制按位取反
--           后置,前置--
++           前置,后置++
*            间接访问操作符(解引用操作符)
(类型)        强制类型转换
```

**`sizeof`:**

```c
#include <stdio.h>
int main()
{
 int a = -10;
 int *p = NULL;
 printf("%d\n", !2);
 printf("%d\n", !0);
 a = -a;
 p = &a;
 printf("%d\n", sizeof(a));
 printf("%d\n", sizeof(int));
 printf("%d\n", sizeof a);//这样写行
 printf("%d\n", sizeof int);//这样写不行
 return 0;
}
//
```

**`sizeof`和数组:**

```c
#include <stdio.h>
void test1(int arr[])
{
 printf("%d\n", sizeof(arr));//(2)//4(指针大小)
}
void test2(char ch[])
{
 printf("%d\n", sizeof(ch));//(4)//4(指针大小)
}
int main()
{
 int arr[10] = {0};
 char ch[10] = {0};
 printf("%d\n", sizeof(arr));//(1)//40
 printf("%d\n", sizeof(ch));//(3)//10
 test1(arr);
 test2(ch);
 return 0;
}
```



## 7. 关系操作符

```
>
>=
<
<=
!=   用于测试"不相等"
==   用于测试"相等"(不可比较字符串)
```

**警告:**

`==`和`=`不要写错,会导致错误.



## 8. 逻辑操作符

```
&&       逻辑与
||       逻辑或
```

**特点:**

```c
#include <stdio.h>
int main()
{
    int i = 0,a=0,b=2,c =3,d=4;
    i = a++ && ++b && d++;
    //i = a++||++b||d++;
    printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
    return 0;
}
```

**&&:**

* 如果左边为假,则停止计算

**||:**

* 如果左边为真,则停止计算



## 9. 条件操作符(三目操作符)

```
exp1 ? exp2 : exp3
```



## 10. 逗号表达式

```c
exp1,exp2,exp3,...expn
```

逗号表达式，就是用逗号隔开的多个表达式。 

逗号表达式，**从左向右依次执行**。

整个表达式的结果是**最后一个表达式的结果**。



## 11. 下标引用,函数调用和结构成员

```
[]    下标引用操作符
()    函数调用操作符
.和->  结构体成员访问操作符
```

1. **[] 下标引用操作符**

操作数:一个数组名 + 一个索引值

```c
int arr[10];//创建数组
 arr[9] = 10;//实用下标引用操作符。
 [ ]的两个操作数是arr和9。
```

2. **() 函数调用操作符**

接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。

```c
#include <stdio.h>
 void test1()
 {
 printf("hehe\n");
 }
 void test2(const char *str)
 {
 printf("%s\n", str);
 }
 int main()
 {
 test1();            //实用（）作为函数调用操作符。
 test2("hello bit.");//实用（）作为函数调用操作符。
 return 0;
 }
```

3. 结构体访问操作符

* .    结构体.成员名
* ->  结构体指针->成员名

```c
#include <stdio.h>
struct Stu
{
 char name[10];
 int age;
 char sex[5];
 double score;
 }；
void set_age1(struct Stu stu)
{
 stu.age = 18;
}
void set_age2(struct Stu* pStu)
{
 pStu->age = 18;//结构成员访问
}
int main()
{
 struct Stu stu;
 struct Stu* pStu = &stu;//结构成员访问
 
 stu.age = 20;//结构成员访问
 set_age1(stu);
 
 pStu->age = 20;//结构成员访问
 set_age2(pStu);
 return 0;
}   
```



## 12. 表达式求值

表达式求值的顺序一部分是由操作符的优先级和结合性决定。 

同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

### 12.1 隐式类型转换

C的整型算术运算总是至少以缺省整型类型的精度来进行的。 

为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为**整型提升**.

**整形提升的意义:**

> 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度 一般就是`int`的字节长度，同时也是CPU的通用寄存器的长度。 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长 度。 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令 中可能有这种字节相加指令）。所以，表达式中各种长度可能小于`int`长度的整型值，都必须先转 换为`int`或`unsigned int`，然后才能送入CPU去执行运算。

**如何进行整型提升的呢?:**

* 按照变量的数据类型的符号位来 提升的.

```c
char a,b,c;
...
a = b + c;
```

b和a 的值被提升为普通类型,然后再执行加法运算.

加法运算完成之后,结果将被截断,然后再存储与a中.

```c
//负数的整形提升
char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：
11111111111111111111111111111111
//正数的整形提升
char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：
00000000000000000000000000000001
//无符号整形提升，高位补0
```

**实例1:**

```c
int main()
{
 char a = 0xb6;
 short b = 0xb600;
 int c = 0xb6000000;
 if(a==0xb6)
 printf("a");
 if(b==0xb600)
 printf("b");
 if(c==0xb6000000)
 printf("c");
 return 0;
}
//输出 C
```

a,b要进行整形提升,但是c不需要整形提升 a,b整形提升之后,变成了负数,所以表达式 a==0xb6 , b==0xb600 的结果是假,但是c不发生整形提升,则表 达式 c==0xb6000000 的结果是真.

**实例2:**

```c
int main()
{
 char c = 1;
 printf("%u\n", sizeof(c));
 printf("%u\n", sizeof(+c));
 printf("%u\n", sizeof(-c));
 return 0;
}
```

c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 `sizeof(+c)` 是4个字 节. 表达式 -c 也会发生整形提升,所以 `sizeof(-c) `是4个字节,但是 `sizeof(c)` ,就是1个字节.



### 12.2 算术转换

如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类 型，否则操作就无法进行。下面的层次体系称为寻常算术转换。

```c
long double
double
float
unsigned long int
long int
unsigned int
int
```

如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运 算。

**警告:**

算术转换要合理，要不然会有一些潜在的问题。

```c
float f = 3.14;
int num = f;//隐式转换，会有精度丢失
```

### 12.3 操作符的属性

复杂表达式的求值有三个影响的因素。 

1. 操作符的优先级 
2. 操作符的结合性
3. 是否控制操作符求值顺序

两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

```c
c + --c;
```

操作符的优先级只能决定自减--的运算在+的运算的前面，但是我们并没有办法得 知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义 的。

```c
int main()
{
 int i = 10;
 i = i-- - --i * ( i = -3 ) * i++ + ++i;
 printf("i = %d\n", i);
 return 0;
}
//在不同编译器中测试结果是不同的
```

```c
#include <stdio.h>
int main()
{
 int i = 1;
 int ret = (++i) + (++i) + (++i);
 printf("%d\n", ret);
 printf("%d\n", i);
 return 0;
}
//结果可能是12 可能是10
//4+4+4
//3+3+4
```

**所以我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题 的。**