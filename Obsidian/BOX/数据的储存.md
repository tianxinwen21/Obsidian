#input #CS #programming_language 
# 数据的储存

## 1. 基本数据类型

- 基本数据类型有:
```c
char        1  //字符数据类型
short       2  //短整型
int         4  //整型
long        4/8//长整型
long long   8  //更长的整型
float       4  //单精度浮点数
double      8  //双精度浮点数

//注意:C语言没有字符串类型
```

>[!类型的意义]
>不同的类型开辟的空间大小不一样,也就是可使用范围也不一样(权限大小)

### 1.1 类型的分类

- **整型家族**
```c

char
unsigned char
signed char
//char 有三种类型,取决于编译器,大部分是(signed char)

//其余四种不标注的就是有符号的类型
short(signed short)
	unsigned short[int]
	signed short[int]

int(signed int)
	unsigned int
	signed int

long(signed long)
	unsigned long[int]
	signed long[int]

long long(signed long long)
	unsigned long long[int]
	signed long long[int]

//[]表示可以省略不写
```

>[!注意]
>字符在内存中存的是ASCII码值


- **浮点数家族**
```c
float
double
```

- **构造类型**: 就是自定义类型,是我们自己创建的新的类型
```c
数组类型
结构体类型 struct
枚举类型   enum
联合类型   union
```

>例如:int arr1[5] 和 int arr2[10]
>       将名字去掉就是类型,类型的关键就在于大小,大小不同就是类型不同.
>       上面的两个数组就是不同的类型.

- **指针类型**
```c
char* pa;
int* pa;
void* p;   //一种特殊类型
//等等
```

- **空类型**
```c
//void 表示空类型,通俗点说就是没有类型
//通常应用在函数的返回类型,函数的参数,指针类型
```

## 2. 整型在内存中的存储

- 创建一个变量就相当于在内存上申请了空间,空间的大小取决于变量的类型.通俗来说,内存就像房子,每个房子的地理位置不会变,就像内存地址不会变,房子的主人会变,就像申请内存的变量名会变一样.

### 2.1 源码,反码,补码

1. 整数的表示方法有三种: 源码 ,反码 ,补码.
2. 三种方法均有**符号位** 和 **数值为**两部分.
3. 符号位用**0表示"正"**,**用1表示"负".

#源码
- 将数字按规定翻译成二进制.

#反码
- 源码的符号位不变,其他位按位取反.

#补码
- 反码+1.

>[!注意]
>1. 正数的源码,反码,补码都相同.
>2. 整型数据在内存中存放的是**补码**.


- **补充知识**
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统 一处理； 同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程 是相同的，不需要额外的硬件电路。

### 2.2 大小端介绍

#### 2.2.1 什么是大小端
#大端存储模式
- 数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中.
- 通俗来说,就是把高位字节数存放在低地址处

#小端存储模式
- 是指数据的低位保存在内存的低地址中，而数据的高位,保存在内存的高地址中.(倒着存)
- 通俗来说就是把低字节序放在低地址处

![[Pasted image 20221124120037.png]]

#### 2.2.2 为什么有大小端
>为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元 都对应着一个字节，一个字节为8.bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编 译器），另外，对于位数大于8位 的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如 何将多个字节安排的问题。因此就 导致了大端存储模式和小端存储模式。 例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为 高字节， 0x22 为低字节。对于大端 模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式， 刚好相反。我们常用的 X86 结构是 小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以 由硬件来选择是大端模式还是小端 模式。

## 3. 浮点型在内存中的存储

- 浮点数其实就是**小数**,根据小数点后位数的不同,也就是精度不同,浮点数可以分为单精度浮点数和双精度浮点数.
- 常见的浮点数表示法: **3.1415(直接表示法)** 和 **1E10(科学计数法)** .
- 浮点数家族包括: **float, double, long double** 类型.
- 浮点数表示的范围: **float.h** 中定义 **(将此文件拖到VS中就可以以看到相信规定)** .

### 3.1 浮点数存储规则

- 根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
> 1. (-1)^S * M * 2^E
> 2. (-1)^s表示**符号位**，当s=0，V为正数；当s=1，V为负数
> 3. M表示**有效数字**，大于等于1，小于2
> 4. 2^E表示**指数位**

- 举个例子来方便理解:
>  - 十进制的 5.5 
>  - 写成二进制是 101.1
>  - 相当于 1.011 * 2^2
>  - 根据规定,可以得出 S = 0, M = 1.011, E = 2

- 图示法:
![[Pasted image 20221125095027.png]]

- **IEEE 754规定** :
对于**32位的浮点数**，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
![[Pasted image 20221125095235.png]]

对于**64位的浮点数**，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M.
![[Pasted image 20221125095348.png]]

- **IEEE 754 对于有效数字M 和指数E,还有一些特别的规定.**

- **关于有效数字M** 
1. 因为有效数字是二进制型式,所以 **1<= M<2** .
2. IEEE 754规定，在计算机内部保存M时，**默认这个数的第一位总是1**，因此可以被舍去，只保存后面的 xxxxxx部分。比如保存1.01的时 候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位， 将第一位的1舍去以后，等于可以保存24位有效数字。

- **对于指数E** 
>如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们 知道，科学计数法中的E是可以出现**负数**的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个**中间数**，对于8位的E，这个中间数是**127**；对于11位的E，这个中间数是**1023**。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即 10001001。

- **指数E从内存中取出还可以分成三种情况** :
1. **E不全为0或不全为1** 
>这时，浮点数就采用下面的规则表示，即指数E的计算值**减去**127（或1023），得到真实值，再将**有效数字M前加上第一位的1** . 比如： 0.5（1/2）的二进制形式为0.1，由于规定**正数部分必须为1**，即将小数点右移1位，则为 1.0\*2^(-1)，其阶码为-1+127=126，表示为 01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:
>0 01111110 00000000000000000000000

2. **E全为0**
>浮点数的指数E等于1-127（或者1-1023）即为真实值， **有效数字M不再加上第一位的1**，而是还原为0.xxxxxx的小数。这样做是为了表示**±0**，以及接近于 0的很小的数字

3. **E全为1**
>如果有效数字M全为0，表示**±无穷大**（正负取决于符号位s）；

### 3.2 一个例子

```c
#include <stdio.h>
int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("%d\n", n);
	printf("%f\n", *pFloat);
	*pFloat = 9.0;
	printf("%d\n", n);
	printf("%f\n", *pFloat);
	return 0;
}
```

![[Pasted image 20221125124403.png]]
- 如图浮点数的储存
![[Pasted image 20221125132530.png]]

