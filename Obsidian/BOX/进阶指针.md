#input #CS #programming_language 
## 1.字符指针
### 1.1 字符指针
* 字符指针用来存放字符的地址,字符表示为`char*`.

```c
int main()
{
	char* str = "txw";//此时字符指针并没有存放字符串,指针存放了字符串的首字母的地址
	printf("%s\n",str);
	printf("%c\n",&str);
	return 0;
}
//txw
//t
```

* 通过上面代码可以看出,字符指针也可以存储字符串,原因在于,字符串可以想象成一个字符数组,存储的方式是连续的存储,将首字母的地址存放在字符指针中.

### 1.2 常量字符串
* 定义方式:
`const char* pstr = "hello txw"`.
- 被`const`修饰的常量无法被修改
* 观察下面一段代码:
```c
#include <stdio.h>

int main()
{
	char str1[] = "hello txw";
	char str2[] = "hello txw";
	const char* str3 = "hello txw";
	const char* str4 = "hello txw";

	if(str1 == str2)//比较的是地址
		printf("yes\n");
	else
		printf("no\n");

	if(str3 == str4)
		printf("yes\n");
	else
		printf("no\n");
	return 0;
}
```
- 这里str3和str4指向的是一个同一个常量字符串。C/C++会把常量字符串存储到单独的一个内存区域.当几个*指针*指向同一个字符串的时候，他们实际会指向同一块内存.
- 但是用相同的常量字符串去初始化不同的数组的时候就会*开辟出不同的内存块*.

## 2. 指针数组
* 指针数组是一个存放指针的*数组*,通俗点说就是存放地址的数组.
* 指针数组是数组,存放的数据类型是指针.

## 3. 数组指针
### 3.1 数组指针的理解
* 首先明确一点,数组指针是*指针
* 采用类比的思路:整型指针是指向整型数据的指针,字符指针是指向字符数据的指针.因此得出,数组指针是指向数组的指针.
* 数组指针的代码表示法:
```c
int (*p)[5];
//p先与*结合,说明p是一个指针变量,然后指向一个大小为5个整型的数组
```

>[!注意]
>1. 指向的意思:指向就是指针变量里存放的地址,这个地址所能检索到的内存块上的数据.
>2. 优先级问题:`[]`的优先级高于`*`,所以必须要加上`()`来保证p先和`*`结合.

##  3.2 数组指针的使用
- 指针数组中存放的是数组的地址,所以可以通过一个简单代码看一下如何使用数组指针
```c
#include <stdio.h>
int main()
{
	int arr[10] = {1,2,3,4,5,6,7,8,9,0};
	int (*p)[10] = &arr;//把数组arr的地址赋值给数组指针变量p
	return 0;
}
```
- 数组指针使用
1. 二维数组的数组名是第一行的地址,传过去的arr相当于一个以为数组,有五个元素
2. test_arr1 直接用一个相同的数组接收
3. test_arr2 用一个一维数组接收
```c
#include <stdio.h>

test_arr1(int arr[3][5],int row,int col)
{
	int i = 0;
	for(i = 0;i<col;i++)
	{
		for(int j = 0;j<col;j++)
		{
			printf("%d ",arr[i][j]);
		}
		printf("\n");
	}
}

test_arr2(int (*arr)[5],int row,intcol)
{
	int i = 0;
	for(i = 0;i<row;i++)
	{
		int j = 0;
		for(j=0;j<col;j++)
		{
			printf("%d ",arr[i][j]);
		}
		printf("%\n");
	}
}
int main()
{
	int arr[3][5] = {1,2,3,4,5};
	test_arr1(arr,3,5);
	test_arr2(arr,3,5);
	return 0;
}
```

## 4. 数组参数和指针参数
- 我们在写代码时难免会遇见要把 数组 或者 函数 传给函数,这时引出一个问题,函数的参数该如何写呢,接着往下探索
### 4.1 一维数组传参
- 观察代码:
```c
#include <stdio.h>
void test(int arr[])    //可行,可以不标注数组的大小
{}
void test(int arr[10])  //可行,可用和传递的数组相同的表示方法
{}
void test(int* arr)     //可行,传过来的是整型指针
{}
void test2(int* arr[20])//可行,与传过来的数组相同
{}
void test2(int** arr)   //可行,传过来的相当于是一级指针
{}
int main()
{
	int arr[10] = { 0 };
	int* arr2[20] = { 0 };
	test(arr);  //传递的是一维数组首元素的地址(整型指针)
	test2(arr2);//传递的是一维数组首元素的地址(一级指针),则相当于传递的是一级指针的地址
}
```

>[!总结]
>1. 一维数组传参时,函数的参数可以是*数组*(可不标注大小)
>2. 一维数组传参时,函数参数还可以是相应的*指针*(一级或者二级)

### 4.2 二维数组传参
- 观察下面代码:
```c
#include <stdio.h>
void test(int arr[3][5])//可行,与传递的数组相同
{}
void test(int arr[][])//不可行,二维数组不可以省略列数
{}
void test(int arr[][5])//可行,可以不知道有多少行,但必须知道有多少列
{}
void test(int* arr)//不可行,传过来的是以为数组的地址,大小为20个字节,函数的参数是整型指针大小为4个字节,大小不匹配
{}
void test(int* arr[5])//不可行,函数的参数是一个指针数组,是数组
{}
void test(int(*arr)[5])//可行,函数的参数是数组指针,是指针
{}
void test(int** arr)//不可行,传过来的不是一级指针的地址,二级指针存放的是一级指针的地址
{}
int main()
{
	int arr[3][5] = { 0 };
	test(arr);//将一维数组的首元素地址传给函数,以为数组的首元素也就是第一行的地址,相当于一个一维数组
	          //传递给函数的是数组指针
}
```

>[!总结]
>二维数组传参时,函数的参数是*数组或数组指针*

### 4.3 一级指针传参
观察下面代码:
```c
#include <stdio.h>
#include <stdio.h>
void print(int* p, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d\n", *(p + i));
	}
}
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
	int* p = arr;//p是一级指针
	int sz = sizeof(arr) / sizeof(arr[0]);

	print(p, sz);//传的是一级指针,而不是一级指针的地址
	return 0;
}
```

>[!总结]
>一级指针传参时,函数用一级指针接收

### 4.4 二级指针传参
- 观察下面代码:
```c
#include <stdio.h>
void test(int** ptr)//二级指针接收
{                   //二级指针可以接收二级指针或者一级指针的地址
	printf("num = %d\n", **ptr);
}
int main()
{
	int n = 10;
	int* p = &n;  //一级指针
	int** pp = &p;//二级指针
	test(pp);     //传的是二级指针
	test(&p);     //传一级指针的地址
	return 0;
}
```

>[!总结]
>二级指针传参时,函数可以用二级指针接收

## 5. 函数指针
### 5.1 函数名是什么
- 首先我们来验证一下函数名的含义,观察下面代码:
```c
#include <stdio.h>
void test()
{
	printf("txw,yyds\n");
}
int main()
{
	printf("%p\n", test);
	printf("%p\n", &test);
	return 0;
}
```

![[Pasted image 20221123201117.png]]
- 观察上面图片可知,函数名就是函数的地址.
### 5.2 函数地址的存储方式
- 存储函数的地址可想而知需要一个指针,要想存储函数,那么必须要与函数相匹配.则需要相同的返回类型和参数.基于上述分析,我们可以尝试写出一个函数指针:
```c
void test()//此test函数无参数,返回类型为void
{}
void (*ptest)();//ptest先与*结合,说明是一个指针,指针指向一个函数,函数无参数,返回类型为void
```

## 6. 函数指针数组
### 6.1 如何定义一函数指针数组
- 通过名字函数指针数组,我们可得这是一个数组,数组的元素类型是函数指针
- 我们试着写出函数指针数组.首先必须是一个数组,其次数组元素类型是函数指针
```c
int (*arr[5])();
```
### 6.2 函数指针数组的用途
- 转移表
- 例子:(加法器)
```c

```

## 7. 指向函数指针数组的指针
### 7.1 如何理解指向函数指针数组的指针
- 指向函数指针数组的指针是一个*指针*
- 指针指向一个数组,数组的类型是函数指针
### 7.2 如何定义
- 我们才能层层递进的方法写出 指向函数指针数组的指针,观察下面代码
```c
void test(char* str)
{
	printf("%s\n",str);
}

int main()
{
	//1.函数指针
	void (*ptest)(char*);
	ptest = test;
	//2.函数指针数组
	void (*ptestsrr[5])(char*);
	ptestarr[0] = test;
	//3.指向函数指针数组的指针
	void (*(*pptestarr)[5])(char*);
	pptestarr = &ptestarr;
	return 0;
}
```

## 8. 回调函数
### 8.1 什么是回调函数
- 回调函数就是一个通过*函数指针*调用的函数.如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数 的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应
### 8.1 使用
